---
title: '2023-11-11'
excerpt: '내 코드가 그렇게 이상한가요? 4 ~ 8장'

categories:
  - TIL
tags:
  - [book]
  - [내코드가그렇게이상한가요]

permalink: /til/2023-11-11/

toc: true
toc_sticky: true

date: 2023-11-11
last_modified_at: 2023-11-11
---

## TIL

### 4장 불변 활용하기: 안정적으로 동작하게 만들기

- 4.1 재할당
  - 변수에 값을 다시 할당하는 것을 재할당 또는 파괴적 할당이라고 합니다. 재할당은 변수의 의미를 바꿔 코드의 의미를 추즉하기 어렵게 만듭니다.
  - 재할당은 final 키워드로 막을 수 있습니다. 매개변수에도 final을 붙혀 재할당을 막을 수 있습니다.
- 4.2 가변으로 인해 발생하는 의도하지 않은 영향
  - 인스턴스가 가변이면 다른 부분에 의도하지 않은 영향을 주기 쉽습니다. 코드를 변경했을 때, 생각하지도 못했던 위치에서 상태가 변화하여 예측하지 못한 동작을 하는 경우가 있습니다. 이러한 부수효과는 함수의 영향범위를 예측하기 힘들게 합니다.
    - 가변 인스턴스 재사용하기
    - 함수로 가변 인스턴스 조작하기
  - 가변 변수는 기능 변경 때에 의도하지 않게 부수 효과가 있는 함수가 만들어져서 예상하지 못한 동작을 일으킬 가능성이 항상 존재하게 됩니다.
- 4.3 불변과 가변은 어떻게 다루어야 할까
  - 불변의 장점
    - 변수의 의미가 변하지 않으므로, 혼란을 줄일 수 있다.
    - 동작이 안정적이게 되므로, 결과를 예측하기 쉽다.
    - 코드의 영향 범위가 하정적이므로, 유지 보수가 편리해진다.
  - 가변이 필요한 경우는?
    - 성능이 중요한 경우, 대량의 데이터를 빠르게 처리해야 하는경우, 이미지를 처리한느 경우

---

### 5장 응집도 : 흩어져 있는 것들

- 5.1 static 메서드 오용
  - static 메서드 오용으로 응집도가 낮아지는 경우가 있습니다.
  - static 메소드는 데이터를 인자로 받아 로직을 수행하므로 데이터와 로직이 분리되어 응집도가 낮아진다.
- 5.2 초기화 로직 분산
  - 클래스를 잘 설계헤도, 초기화 로직이 분산되어 응집도가 낮은 구조가 되어 버리는 경우가 있습니다.
  - private 생성자 + 팩토리 메서드를 사용해 목적에 따라 초기화하기
    - 초기화 로직이 한데모여 있어 유지보수와 코드의 의미를 파악하기 쉽다.
- 5.3 범용 처리 클래스 (Common/Util)
  - 횡단 관심사
    - 로그 출력, 오류 확인, 디버깅, 예외 처리, 캐시, 동기화, 분산처리
- 5.4 결과를 리턴하는 데 매개변수 사용하지 않기

  - 데이터의 조작은 Location, 조작 로직은 ActorManager입니다.
  - 응집도가 낮은 구조는 중복을 만듭니다.
  - 데이터와 데이터를 조작하는 로직을 같은 클래스에 배치합시다.

  ```
  class ActorManager {
    // 게임 캐릭터 위치를 이동
    void shift(Location location, int shiftX, int shiftY) {
      location.x += shiftX;
      location.y += shiftY;
    }
  }
  ```

  - 이동 메서드 shift는 위치를 나타내는 location 클래스에 정의합시다.

  ```
  Location(final int x, final int y) {
    this.x = x;
    this.y = y;
  }

  Location shift(final int shiftX, final int shiftY) {
    final int nextX = x + shiftX;
    final int nextY = y + shiftY;
    return new Location(nextX, nextY);
  }
  ```

- 5.5 매개변수가 너무 많은 경우
  - 매개변수가 너무 맣은 메서드는 응집도가 낮아지기 쉽습니다.
  - 의미 있는 단위는 모두 클래스로 만들기
    - 매개변수가 많으면 데이터 하나하나를 매개변수로 다루지 말고, 그 데이터를 인스턴스 변수로 갖는 클래스를 만들고 활용하는 설계로 변경해보세요.
- 5.6 메서드 체인
  - 데메테르 법칙
    - 사용하는 객체 내부를 알아서는 안된다.
    - '모르는 사람에게 말을 걸지 않기'
    - 묻지 말고, 명령하기

---

### 6장 조건 분기: 미궁처럼 복잡한 분기 처리를 무너뜨리는 방법

- 6.1 조건 분기가 중첩되어 낮아지는 가독성
  - 조기 리턴 -> 조건 로직과 실행 로직을 분리 할 수 있다.
- 6.2 switch 조건문 중복
  - 단일 책임 선택의 원칙
    - 소프트웨어 시스템이 선택지를 제공해야 한다면, 그 시스템 내부의 어떤 한 모듈만으로 모든 선택지를 파악할 수 있어햐 한다.
    - 조건식이 같은 조선 분기를 여러 번 작성하지 말고 한 번에 작성하자는 뜻입니다.
  - 전략 패턴
- 6.3 조건 분기 중복과 중첩
  - 정책 패턴
    - 조건을 부품처럼 만들고, 부품으로 만든 조건을 조합해서 사용하는 패턴
- 6.4 자료형 확인에 조건 분기 사용하지 않기
  - 리스코프 치환 원칙 위반
    - 클래스 기반 자료형과 하위 자료형 사이에 성립하는 규칙
    - 기반 자료형을 하위 자료형으로 변경해도 코드는 문제 없이 동작해야 한다.
    - 숙박 요금을 나타낸느 인터페이스
    ```
    interface HotalRates {
      Money fee();
    }
    ```
    - 일반 객실 요금
    ```
    class RegularRates implements HotelRates {
      public Money fee() {
        return new Money(70000);
      }
    }
    ```
    - 프리미엄 객실 요금
    ```
    class PermiumRates implements HotelRates {
      public Money fee() {
        return new Money(120000);
      }
    }
    ```
    - 그럼 성수기 일때는?
    - 아래 코드는 리스코프 치환 원칙을 위배될 수 있기 때문에 instanceof로 객체의 구현체를 판단하여 로직을 수행하고 있다.
      - RegularRates대신 PremiumRates에 30000이 추가 된다면 리스코프 치환 원칙이 위배된다.
    ```
    Money busySeasonFee;
    if (hotelRates instanceof RegularRates) {
      busySeasonFee = hotelRates.fee().add(new Money(30000));
    } else if (hotelRates instanceof PremiumRates) {
      busySeasonFee = hotelRates.fee().add(new Money(50000));
    }
    ```
    - 성수기 요금도 인터페이스로 변경하여 HotelsRates 인터페이스에 성수기 요금을 리턴하는 busySeasonFee 메서드를 추가합니다.
  - 6.5 인터페이스 사용능력이 중급으로 올라가는 첫걸음
    - 조건 분기를 써야하는 상황에서는 일단 인터페이스 설계를 떠올리자!
  - 6.6 플래그 매개변수
    - 플래그 매개변수를 받는 메서드는 어떤 일을 하는지 예측하기 굉장히 힘듭니다. 예측을 하기 위해서는 반드시 메서드 내부 로직을 확인해야 하므로, 가독성이 낮아지며 개발 생산성이 저하됩니다.
    - 6.6.1 메서드 분리하기
      - 플래그 매개변수를 받는 메서드는 내부적으로 여러 기능을 수행하고 있으며, 플래그를 사용해서 이를 전환하는 구조를 갖습니다. 메서드는 하나의 기능만 하도록 설계하는 것이 좋습니다. 따라서 플래그 매개변수를 받는 메서드는 기능별로 분리하는 것이 좋습니다.

---

### 7장 컬렉션: 중첩을 제거하는 구조화 테크닉

- 7.1 이미 존재하는 기능을 다시 구현하지 말기
  - stream 표준 라이브러리에 같은 기능을 하는 메서드가 있는지 확인하기
- 7.2 반복 처리 내부의 조건 분기 중첩
  - 조기 continue와 조기 break로 가독성을 높히자!
- 7.3 응집도가 낮은 컬렉션 처리
- 7.3.1 컬렉션 처리를 캡슐화하기
  - 컬렉션과 관련된 응집도가 낮아지는 문제는 일급 컬렉션 패턴을 사용해 해결할 수 있습니다. 일급 컬렉션이란 컬렉션과 관련된 로직을 캡슐화하는 디자인 패턴입니다.
  - 일급컬렉션 구성 요소
    - 컬렉션 자료형의 인스턴스 변수
    - 컬렉션 자료형의 인스턴스 변수에 잘못된 값이 할당되지 않게 막고, 정상적으로 조작하는 메서드
  - 외부로 전달할때는 컬렉션의 변경 막기
    - 외부로 전달할 때는 컬렉셔 요소를 변경하지 못하게 막아 두는 것이 좋습니다. 이 때는 unmodifiableList 메서드를 사용합니다.

---

### 8장 강한 결합: 복잡하게 얽혀서 풀 수 없는 구조

- 결합도
  - 모듈 사이의 이ㅡ존도를 나타내는 지표
  - 어떤 클래스가 다른 클래스에 많이 의존하고 있는 구조를 강한 결합이라고 부릅니다.
  - 결합도가 낮은 구조를 느슨한 결합이라고 부릅니다.
- 8.1 결합도와 책무
  - 책무가 고려되지 않은 설계는 로직의 위치에 일관성이 없습니다.
  - 단일 책임의 원칙
    - 소프트웨어의 책임이란 '자신의 관심사와 관련해서, 정상적으로 동작하 도록 제어하는 것'
    - 단일 책임의 원칙이란 '클래스가 담당하는 책임은 하나로 제한해야 한다.'
    - 중복 vs 책무
      - 책무를 생각하지 않고 로직의 중복을 제거하면 안됩니다.
      - 그렇게 되면 하나로 모인 로직이 여러 책무를 담당해야 합니다.
      - 같은 로직, 비슷한 로직이라도 개념이 다르면 중복을 허용해야 합니다.
- 8.2 다양한 강한 결합 사례와 대처 방법
  - 8.2.1 상속과 관련된 강한 결합
    - 상속은 주의해서 다루지 않으면, 곧바로 강한 결합 구조를 유발합니다.
  - 상속보다 컴포지션
  - 특별한 이유 없이 public 사용하지 않기
  - private 메서드가 너무 많다는 것은 책임이 너무 많다는 것

## 오늘의 회고

- 내 코드가 그렇게 이상한가요? 스터디.. 책을 깊게 못읽고가서 다시 다 읽고 정리했다.
- 조금씩 투자해서 읽고 생각하고 스터디를 가야겠따.
